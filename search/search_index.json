{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TornOpen \u00b6 TornOpen is a drop-in extension to the Tornado Web Server that is heavily inspired by FastAPI . It uses type annotation and pydantic to validate request parameters and generate documentation that are compliant with the OpenAPI Specification (OAS) and viewable using Redoc . Why TornOpen? \u00b6 Existing solutions to generating OpenAPI Specifications in code such as tornado-swagger , swagger-doc and Tornado OpenAPI 3 , requires that documentation are written as docstrings or as code that does not contribute to the actual usage of the handlers. Both require some amount of knowledge of the OAS. The resulting problem is that documentation does not always line up perfectly with actual implementation. TornOpen attempts to solve this problem by removing the task of writing documentation; the developer provides necessary information through type annotations, decorators and docstrings, and TornOpen will generate an OAS compliant specification when the application is run.","title":"TornOpen"},{"location":"#tornopen","text":"TornOpen is a drop-in extension to the Tornado Web Server that is heavily inspired by FastAPI . It uses type annotation and pydantic to validate request parameters and generate documentation that are compliant with the OpenAPI Specification (OAS) and viewable using Redoc .","title":"TornOpen"},{"location":"#why-tornopen","text":"Existing solutions to generating OpenAPI Specifications in code such as tornado-swagger , swagger-doc and Tornado OpenAPI 3 , requires that documentation are written as docstrings or as code that does not contribute to the actual usage of the handlers. Both require some amount of knowledge of the OAS. The resulting problem is that documentation does not always line up perfectly with actual implementation. TornOpen attempts to solve this problem by removing the task of writing documentation; the developer provides necessary information through type annotations, decorators and docstrings, and TornOpen will generate an OAS compliant specification when the application is run.","title":"Why TornOpen?"},{"location":"application/","text":"The Application class \u00b6 The Application class subclasses Tornado's Application class and adds additional options for customizing the OpenAPI and Redoc routes. On initialization, the Application class wil review the handlers and generate OpenAPI spec. If you are adopting TornOpen to an existing Tornado application, you can simply replace the Tornado's Application class with TornOpen's Application class. TornOpen's Application is able to work with Tornado's RequestHandler. __init__ ( self , handlers , * , openapi_yaml_route = '/openapi.yaml' , openapi_json_route = '/openapi.json' , redoc_route = '/redoc' , ** settings ) special \u00b6 Parameters: Name Type Description Default handlers list of routes and handlers required openapi_yaml_route str Route for openapi.yaml '/openapi.yaml' openapi_json_route str Route for openapi.json '/openapi.json' redoc_route str Route for redoc '/redoc' **settings Settings for Tornado's Application {}","title":"Application"},{"location":"application/#the-application-class","text":"The Application class subclasses Tornado's Application class and adds additional options for customizing the OpenAPI and Redoc routes. On initialization, the Application class wil review the handlers and generate OpenAPI spec. If you are adopting TornOpen to an existing Tornado application, you can simply replace the Tornado's Application class with TornOpen's Application class. TornOpen's Application is able to work with Tornado's RequestHandler.","title":"The Application class"},{"location":"application/#torn_open.web.Application.__init__","text":"Parameters: Name Type Description Default handlers list of routes and handlers required openapi_yaml_route str Route for openapi.yaml '/openapi.yaml' openapi_json_route str Route for openapi.json '/openapi.json' redoc_route str Route for redoc '/redoc' **settings Settings for Tornado's Application {}","title":"__init__()"},{"location":"introduction/","text":"Introduction \u00b6 Installation \u00b6 $ pip install torn-open Hello, World \u00b6 # ./app.py from tornado.web import url from torn_open import AnnotatedHandler , ResponseModel , Application class HelloWorldResponse ( ResponseModel ): \"\"\" This is my hello world response \"\"\" greeting : str class HelloWorldHandler ( AnnotatedHandler ): def get ( self , name : str ) -> HelloWorldResponse : \"\"\" This is my get request documentation \"\"\" return HelloWorldResponse ( greeting = f \"Hello, { name } \" ) app = Application ([ url ( r \"/hello/(?P<name>[^/]+)\" , HellowWorldHandler ), ]) if __name__ == \"__main__\" : app . listen ( 8888 ) IOLoop . current () . start () (This script is complete, it should run \"as is\") Starting the Server \u00b6 $ python app.py Retrieving the OpenAPI spec \u00b6 $ curl http://localhost:8888/openapi.yaml info : title : tornado-server version : 1.0.0 openapi : 3.0.0 paths : /hello/{name} : get : description : This is my get request documentation responses : '200' : content : application/json : schema : description : This is my hello world response properties : greeting : title : Greeting type : string required : - greeting title : HelloWorldResponse type : object description : This is my hello world response parameters : - in : path name : name required : true schema : type : string The spec can also be retrieved in json with curl http://localhost:8888/openapi.json . Viewing your documentation on Redoc \u00b6 The Redoc page for the annotated handlers can be found at http//localhost:8888/redoc .","title":"Quick start"},{"location":"introduction/#introduction","text":"","title":"Introduction"},{"location":"introduction/#installation","text":"$ pip install torn-open","title":"Installation"},{"location":"introduction/#hello-world","text":"# ./app.py from tornado.web import url from torn_open import AnnotatedHandler , ResponseModel , Application class HelloWorldResponse ( ResponseModel ): \"\"\" This is my hello world response \"\"\" greeting : str class HelloWorldHandler ( AnnotatedHandler ): def get ( self , name : str ) -> HelloWorldResponse : \"\"\" This is my get request documentation \"\"\" return HelloWorldResponse ( greeting = f \"Hello, { name } \" ) app = Application ([ url ( r \"/hello/(?P<name>[^/]+)\" , HellowWorldHandler ), ]) if __name__ == \"__main__\" : app . listen ( 8888 ) IOLoop . current () . start () (This script is complete, it should run \"as is\")","title":"Hello, World"},{"location":"introduction/#starting-the-server","text":"$ python app.py","title":"Starting the Server"},{"location":"introduction/#retrieving-the-openapi-spec","text":"$ curl http://localhost:8888/openapi.yaml info : title : tornado-server version : 1.0.0 openapi : 3.0.0 paths : /hello/{name} : get : description : This is my get request documentation responses : '200' : content : application/json : schema : description : This is my hello world response properties : greeting : title : Greeting type : string required : - greeting title : HelloWorldResponse type : object description : This is my hello world response parameters : - in : path name : name required : true schema : type : string The spec can also be retrieved in json with curl http://localhost:8888/openapi.json .","title":"Retrieving the OpenAPI spec"},{"location":"introduction/#viewing-your-documentation-on-redoc","text":"The Redoc page for the annotated handlers can be found at http//localhost:8888/redoc .","title":"Viewing your documentation on Redoc"},{"location":"request_handler/","text":"The AnnotatedHandler class \u00b6 The AnnotatedHandler class subclasses from Tornado's RequestHandler. Subclasses of the AnnotatedHandler are able to - declare path and query params, json body model and the response model in the function signature - validate, type cast and pass in declared params before declared methods are executed Differences \u00b6 With Tornado, we subclass from the RequestHandler and define the path parameter in the overridden get method. We then retrieve query params and json body by using methods like get_query_argument and parsing the request body. from tornado.escape import json_decode from tornado.web import RequestHandler class TornadoRequestHandler ( RequestHandler ): async def get ( self , a_path_param ): a_query_param = int ( self . get_query_argument ( \"a_query_param\" )) a_request_body = json_decode ( self . request . body ) self . write ({ \"a_path_param\" : a_path_param , \"a_query_param\" : a_query_param , \"a_request_body\" : a_request_body , }) For subclasses of AnnotatedHandler , the annotated function arguments will be used to parse the incoming request for the required fields, and passed into the functions. from torn_open import AnnotatedHandler , RequestModel , ResponseModel class ARequestBody ( RequestModel ): a_body_param : bool class AResponseModel ( ResponseModel ): a_path_param : str a_query_param : int request_body : ARequestBody class TornOpenAnnotatedHandler ( AnnotatedHandler ): async def get ( self , a_path_param : str , a_query_param : int , a_request_body : ARequestBody ) -> AResponseModel : return AResponseModel ( a_path_param = a_path_param , a_query_param = a_query_param , a_request_body = a_request_body , ) Parameters \u00b6 The AnnotatedHandler uses a set of rules to determine where the parameter should be parsed from Path parameters \u00b6 If an argument appears in the url rule for the handler, it is treated as a path parameter 1 or more path parameters can be declared in the url rule. If the url rule includes a path parameter that is not in the function signature, an error may be raised at runtime. TODO: Consider how to handler more path parameters than required provided Query parameters \u00b6 If an argument does not appear in the url rule for the handler, and its type annotation is not a subclass of torn_open.RequestModel , it is treated as a query parameter. JSON body \u00b6 If an argument does not appear in the url rule for the handler, and its type annotation is a subclass of torn_open.RequestModel , then it is parsed as a JSON object. Only 1 argument in a function can be annotated as a subclass of torn_open.RequestModel .","title":"AnnotatedHandler"},{"location":"request_handler/#the-annotatedhandler-class","text":"The AnnotatedHandler class subclasses from Tornado's RequestHandler. Subclasses of the AnnotatedHandler are able to - declare path and query params, json body model and the response model in the function signature - validate, type cast and pass in declared params before declared methods are executed","title":"The AnnotatedHandler class"},{"location":"request_handler/#differences","text":"With Tornado, we subclass from the RequestHandler and define the path parameter in the overridden get method. We then retrieve query params and json body by using methods like get_query_argument and parsing the request body. from tornado.escape import json_decode from tornado.web import RequestHandler class TornadoRequestHandler ( RequestHandler ): async def get ( self , a_path_param ): a_query_param = int ( self . get_query_argument ( \"a_query_param\" )) a_request_body = json_decode ( self . request . body ) self . write ({ \"a_path_param\" : a_path_param , \"a_query_param\" : a_query_param , \"a_request_body\" : a_request_body , }) For subclasses of AnnotatedHandler , the annotated function arguments will be used to parse the incoming request for the required fields, and passed into the functions. from torn_open import AnnotatedHandler , RequestModel , ResponseModel class ARequestBody ( RequestModel ): a_body_param : bool class AResponseModel ( ResponseModel ): a_path_param : str a_query_param : int request_body : ARequestBody class TornOpenAnnotatedHandler ( AnnotatedHandler ): async def get ( self , a_path_param : str , a_query_param : int , a_request_body : ARequestBody ) -> AResponseModel : return AResponseModel ( a_path_param = a_path_param , a_query_param = a_query_param , a_request_body = a_request_body , )","title":"Differences"},{"location":"request_handler/#parameters","text":"The AnnotatedHandler uses a set of rules to determine where the parameter should be parsed from","title":"Parameters"},{"location":"request_handler/#path-parameters","text":"If an argument appears in the url rule for the handler, it is treated as a path parameter 1 or more path parameters can be declared in the url rule. If the url rule includes a path parameter that is not in the function signature, an error may be raised at runtime. TODO: Consider how to handler more path parameters than required provided","title":"Path parameters"},{"location":"request_handler/#query-parameters","text":"If an argument does not appear in the url rule for the handler, and its type annotation is not a subclass of torn_open.RequestModel , it is treated as a query parameter.","title":"Query parameters"},{"location":"request_handler/#json-body","text":"If an argument does not appear in the url rule for the handler, and its type annotation is a subclass of torn_open.RequestModel , then it is parsed as a JSON object. Only 1 argument in a function can be annotated as a subclass of torn_open.RequestModel .","title":"JSON body"}]}