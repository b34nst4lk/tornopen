{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TornOpen \u00b6 TornOpen is a drop-in extension to the Tornado Web Server that is heavily inspired by FastAPI . It uses type annotation and pydantic to validate request parameters and generate documentation that are compliant with the OpenAPI Specification (OAS) and viewable using Redoc . Why TornOpen? \u00b6 Existing solutions to generating OpenAPI Specifications in code such as tornado-swagger , swagger-doc and Tornado OpenAPI 3 , requires that documentation are written as docstrings or as code that does not contribute to the actual usage of the handlers. Both require some amount of knowledge of the OAS. The resulting problem is that documentation does not always line up perfectly with actual implementation. TornOpen attempts to solve this problem by removing the task of writing documentation; the developer provides necessary information through type annotations, decorators and docstrings, and TornOpen will generate an OAS compliant specification when the application is run.","title":"TornOpen"},{"location":"#tornopen","text":"TornOpen is a drop-in extension to the Tornado Web Server that is heavily inspired by FastAPI . It uses type annotation and pydantic to validate request parameters and generate documentation that are compliant with the OpenAPI Specification (OAS) and viewable using Redoc .","title":"TornOpen"},{"location":"#why-tornopen","text":"Existing solutions to generating OpenAPI Specifications in code such as tornado-swagger , swagger-doc and Tornado OpenAPI 3 , requires that documentation are written as docstrings or as code that does not contribute to the actual usage of the handlers. Both require some amount of knowledge of the OAS. The resulting problem is that documentation does not always line up perfectly with actual implementation. TornOpen attempts to solve this problem by removing the task of writing documentation; the developer provides necessary information through type annotations, decorators and docstrings, and TornOpen will generate an OAS compliant specification when the application is run.","title":"Why TornOpen?"},{"location":"application/","text":"The Application class \u00b6 The Application class subclasses Tornado's Application class and adds additional options for customizing the OpenAPI and Redoc routes. On initialization, the Application class wil review the handlers and generate OpenAPI spec. If you are using TornOpen on an existing Tornado application, you can simply replace the Tornado's Application class with TornOpen's Application class. TornOpen's Application is able to work with Tornado's RequestHandler. __init__ ( self , rules , * , openapi_yaml_route = '/openapi.yaml' , openapi_json_route = '/openapi.json' , redoc_route = '/redoc' , ** settings ) special \u00b6 Parameters: Name Type Description Default rules list of routes and handlers required openapi_yaml_route str Route for openapi.yaml '/openapi.yaml' openapi_json_route str Route for openapi.json '/openapi.json' redoc_route str Route for redoc '/redoc' **settings Settings for Tornado's Application {}","title":"Application"},{"location":"application/#the-application-class","text":"The Application class subclasses Tornado's Application class and adds additional options for customizing the OpenAPI and Redoc routes. On initialization, the Application class wil review the handlers and generate OpenAPI spec. If you are using TornOpen on an existing Tornado application, you can simply replace the Tornado's Application class with TornOpen's Application class. TornOpen's Application is able to work with Tornado's RequestHandler.","title":"The Application class"},{"location":"application/#torn_open.web.Application.__init__","text":"Parameters: Name Type Description Default rules list of routes and handlers required openapi_yaml_route str Route for openapi.yaml '/openapi.yaml' openapi_json_route str Route for openapi.json '/openapi.json' redoc_route str Route for redoc '/redoc' **settings Settings for Tornado's Application {}","title":"__init__()"},{"location":"decorators/","text":"Decorators \u00b6 TornOpen provides some function decorators to provide OpenAPI information. Tags \u00b6 With the OpenAPI Specifications, operations can grouped by tags . The tags decorator allows you to add one or more tags to an operation and the resulting spec will be tagged accordingly. Example \u00b6 from tornado.web import url from torn_open import AnnotatedHandler , tags , Application , ResponseModel class AResponseModel ( ResponseModel ): \"This can be ignored\" pass class TaggedRequestHandler ( AnnotatedHandler ): @tags ( \"tag_1\" , \"tag_2\" ) def get ( self ) -> AResponseModel : pass app = Application ([ url ( \"/tagged\" , TaggedRequestHandler )]) Spec output \u00b6 info : title : tornado-server version : 1.0.0 openapi : 3.0.0 paths : /tagged : get : responses : '200' : content : application/json : schema : description : This can be ignored properties : {} title : AResponseModel type : object description : This can be ignored tags : - tag_1 - tag_2 Summary \u00b6 The summary provides a short description for an operation. By default, if the sumary is not provided, ReDoc uses the long description, which is not always ideal. The summary decorator allows you to add a summary to an operation. Example \u00b6 from tornado.web import url from torn_open import AnnotatedHandler , summary , Application , ResponseModel class AResponseModel ( ResponseModel ): \"This can be ignored\" pass class SummaryRequestHandler ( AnnotatedHandler ): @summary ( \"This is a short description of the operation\" ) def get ( self ) -> AResponseModel : pass app = Application ([ url ( \"/summary\" , SummaryRequestHandler )]) Spec output \u00b6 info : title : tornado-server version : 1.0.0 openapi : 3.0.0 paths : /summary : get : responses : '200' : content : application/json : schema : description : This can be ignored properties : {} title : AResponseModel type : object description : This can be ignored summary : This is a short description of the operation","title":"Decorators"},{"location":"decorators/#decorators","text":"TornOpen provides some function decorators to provide OpenAPI information.","title":"Decorators"},{"location":"decorators/#tags","text":"With the OpenAPI Specifications, operations can grouped by tags . The tags decorator allows you to add one or more tags to an operation and the resulting spec will be tagged accordingly.","title":"Tags"},{"location":"decorators/#torn_open.api_spec.decorators.tags--example","text":"from tornado.web import url from torn_open import AnnotatedHandler , tags , Application , ResponseModel class AResponseModel ( ResponseModel ): \"This can be ignored\" pass class TaggedRequestHandler ( AnnotatedHandler ): @tags ( \"tag_1\" , \"tag_2\" ) def get ( self ) -> AResponseModel : pass app = Application ([ url ( \"/tagged\" , TaggedRequestHandler )])","title":"Example"},{"location":"decorators/#torn_open.api_spec.decorators.tags--spec-output","text":"info : title : tornado-server version : 1.0.0 openapi : 3.0.0 paths : /tagged : get : responses : '200' : content : application/json : schema : description : This can be ignored properties : {} title : AResponseModel type : object description : This can be ignored tags : - tag_1 - tag_2","title":"Spec output"},{"location":"decorators/#summary","text":"The summary provides a short description for an operation. By default, if the sumary is not provided, ReDoc uses the long description, which is not always ideal. The summary decorator allows you to add a summary to an operation.","title":"Summary"},{"location":"decorators/#torn_open.api_spec.decorators.summary--example","text":"from tornado.web import url from torn_open import AnnotatedHandler , summary , Application , ResponseModel class AResponseModel ( ResponseModel ): \"This can be ignored\" pass class SummaryRequestHandler ( AnnotatedHandler ): @summary ( \"This is a short description of the operation\" ) def get ( self ) -> AResponseModel : pass app = Application ([ url ( \"/summary\" , SummaryRequestHandler )])","title":"Example"},{"location":"decorators/#torn_open.api_spec.decorators.summary--spec-output","text":"info : title : tornado-server version : 1.0.0 openapi : 3.0.0 paths : /summary : get : responses : '200' : content : application/json : schema : description : This can be ignored properties : {} title : AResponseModel type : object description : This can be ignored summary : This is a short description of the operation","title":"Spec output"},{"location":"error_handling/","text":"Error Handling \u00b6 TornOpen provides ClientError and ServerError for raising expected exceptions. Both ClientError and ServerError inherits from tornopen.models.HTTPJsonError . Usage \u00b6 from torn_open import AnnotatedHandler , ClientError , ResponseModel , Application class AResponseModel ( ResponseModel ): \"\"\" My response model \"\"\" number : int class ErrorHandler ( AnnotatedHandler ): async def get ( self , number : str ) -> AResponseModel : try : number = int ( number ) except ValueError as e : raise ClientError ( status_code = 400 , error_type = \"invalid number\" , ) from e return AResponseModel ( number = number ) application = Application ([( \"/error\" , ErrorHandler )]) OpenAPI Specification \u00b6 On application start, TornOpen parses the overridden HTTP methods for instantiations of ClientError and ServerError , and includes them in the OpenAPI Specifications. Note that ClientError or ServerError raised outside of the HTTP methods will not be reflected on the OpenAPI spec. Currently, only ClientError and ServerError are compatible with the AnnotatedHandler . There are plans to generalize error handling and allowing users to define their own error classes. paths : \"/error\" : get : parameters : - name : number in : query required : true schema : type : string responses : '200' : description : My response model content : application/json : schema : title : AResponseModel description : My response model type : object properties : number : title : Number type : integer required : - number '400' : description : invalid number content : application/json : schema : type : object properties : status_code : type : number type : type : string enum : - invalid number message : type : string required : - status_code - type info : title : tornado-server version : 1.0.0 openapi : 3.0.0","title":"Error Handling"},{"location":"error_handling/#error-handling","text":"TornOpen provides ClientError and ServerError for raising expected exceptions. Both ClientError and ServerError inherits from tornopen.models.HTTPJsonError .","title":"Error Handling"},{"location":"error_handling/#usage","text":"from torn_open import AnnotatedHandler , ClientError , ResponseModel , Application class AResponseModel ( ResponseModel ): \"\"\" My response model \"\"\" number : int class ErrorHandler ( AnnotatedHandler ): async def get ( self , number : str ) -> AResponseModel : try : number = int ( number ) except ValueError as e : raise ClientError ( status_code = 400 , error_type = \"invalid number\" , ) from e return AResponseModel ( number = number ) application = Application ([( \"/error\" , ErrorHandler )])","title":"Usage"},{"location":"error_handling/#openapi-specification","text":"On application start, TornOpen parses the overridden HTTP methods for instantiations of ClientError and ServerError , and includes them in the OpenAPI Specifications. Note that ClientError or ServerError raised outside of the HTTP methods will not be reflected on the OpenAPI spec. Currently, only ClientError and ServerError are compatible with the AnnotatedHandler . There are plans to generalize error handling and allowing users to define their own error classes. paths : \"/error\" : get : parameters : - name : number in : query required : true schema : type : string responses : '200' : description : My response model content : application/json : schema : title : AResponseModel description : My response model type : object properties : number : title : Number type : integer required : - number '400' : description : invalid number content : application/json : schema : type : object properties : status_code : type : number type : type : string enum : - invalid number message : type : string required : - status_code - type info : title : tornado-server version : 1.0.0 openapi : 3.0.0","title":"OpenAPI Specification"},{"location":"introduction/","text":"Introduction \u00b6 Installation \u00b6 $ pip install torn-open Hello, World \u00b6 # ./app.py from tornado.web import url from torn_open import AnnotatedHandler , ResponseModel , Application class HelloWorldResponse ( ResponseModel ): \"\"\" This is my hello world response \"\"\" greeting : str class HelloWorldHandler ( AnnotatedHandler ): def get ( self , name : str ) -> HelloWorldResponse : \"\"\" This is my get request documentation \"\"\" return HelloWorldResponse ( greeting = f \"Hello, { name } \" ) app = Application ([ url ( r \"/hello/(?P<name>[^/]+)\" , HellowWorldHandler ), ]) if __name__ == \"__main__\" : app . listen ( 8888 ) IOLoop . current () . start () (This script is complete, it should run \"as is\") Starting the Server \u00b6 $ python app.py Retrieving the OpenAPI spec \u00b6 $ curl http://localhost:8888/openapi.yaml info : title : tornado-server version : 1.0.0 openapi : 3.0.0 paths : /hello/{name} : get : description : This is my get request documentation responses : '200' : content : application/json : schema : description : This is my hello world response properties : greeting : title : Greeting type : string required : - greeting title : HelloWorldResponse type : object description : This is my hello world response parameters : - in : path name : name required : true schema : type : string The spec can also be retrieved in json with curl http://localhost:8888/openapi.json . Viewing your documentation on Redoc \u00b6 The Redoc page for the annotated handlers can be found at http//localhost:8888/redoc .","title":"Quick start"},{"location":"introduction/#introduction","text":"","title":"Introduction"},{"location":"introduction/#installation","text":"$ pip install torn-open","title":"Installation"},{"location":"introduction/#hello-world","text":"# ./app.py from tornado.web import url from torn_open import AnnotatedHandler , ResponseModel , Application class HelloWorldResponse ( ResponseModel ): \"\"\" This is my hello world response \"\"\" greeting : str class HelloWorldHandler ( AnnotatedHandler ): def get ( self , name : str ) -> HelloWorldResponse : \"\"\" This is my get request documentation \"\"\" return HelloWorldResponse ( greeting = f \"Hello, { name } \" ) app = Application ([ url ( r \"/hello/(?P<name>[^/]+)\" , HellowWorldHandler ), ]) if __name__ == \"__main__\" : app . listen ( 8888 ) IOLoop . current () . start () (This script is complete, it should run \"as is\")","title":"Hello, World"},{"location":"introduction/#starting-the-server","text":"$ python app.py","title":"Starting the Server"},{"location":"introduction/#retrieving-the-openapi-spec","text":"$ curl http://localhost:8888/openapi.yaml info : title : tornado-server version : 1.0.0 openapi : 3.0.0 paths : /hello/{name} : get : description : This is my get request documentation responses : '200' : content : application/json : schema : description : This is my hello world response properties : greeting : title : Greeting type : string required : - greeting title : HelloWorldResponse type : object description : This is my hello world response parameters : - in : path name : name required : true schema : type : string The spec can also be retrieved in json with curl http://localhost:8888/openapi.json .","title":"Retrieving the OpenAPI spec"},{"location":"introduction/#viewing-your-documentation-on-redoc","text":"The Redoc page for the annotated handlers can be found at http//localhost:8888/redoc .","title":"Viewing your documentation on Redoc"},{"location":"request_handler/","text":"The AnnotatedHandler class \u00b6 The AnnotatedHandler class subclasses from Tornado's RequestHandler. Subclasses of the AnnotatedHandler are able to - declare path and query params, json body model and the response model in the function signature - validate, type cast and pass in declared params before declared methods are executed Differences \u00b6 With Tornado, we subclass from the RequestHandler and define the path parameter in the overridden get method. We then retrieve query params and json body by using methods like get_query_argument and parsing the request body. from tornado.escape import json_decode from tornado.web import RequestHandler class TornadoRequestHandler ( RequestHandler ): async def get ( self , a_path_param ): a_query_param = int ( self . get_query_argument ( \"a_query_param\" )) a_request_body = json_decode ( self . request . body ) self . write ( { \"a_path_param\" : a_path_param , \"a_query_param\" : a_query_param , \"a_request_body\" : a_request_body , } ) For subclasses of AnnotatedHandler , the annotated function arguments are used to parse the incoming request for the required fields, and passed into the functions. from torn_open import AnnotatedHandler , RequestModel , ResponseModel class ARequestBody ( RequestModel ): a_body_param : bool class AResponseModel ( ResponseModel ): a_path_param : str a_query_param : int request_body : ARequestBody class TornOpenAnnotatedHandler ( AnnotatedHandler ): async def get ( self , a_path_param : str , a_query_param : int , a_request_body : ARequestBody ) -> AResponseModel : return AResponseModel ( a_path_param = a_path_param , a_query_param = a_query_param , a_request_body = a_request_body , ) Parameters \u00b6 The AnnotatedHandler uses a set of rules to determine where the parameter should be parsed from Path parameters \u00b6 If an argument appears in the url rule for the handler, it is treated as a path parameter 1 or more path parameters can be declared in the url rule. If the url rule includes a path parameter that is not in the function signature, an error may be raised at runtime. Query parameters \u00b6 If an argument does not appear in the url rule for the handler, and its type annotation is not a subclass of torn_open.RequestModel , it is treated as a query parameter. JSON body \u00b6 If an argument does not appear in the url rule for the handler, and its type annotation is a subclass of torn_open.RequestModel , then it is parsed as a JSON object. Only 1 argument in a function can be annotated as a subclass of torn_open.RequestModel .","title":"AnnotatedHandler"},{"location":"request_handler/#the-annotatedhandler-class","text":"The AnnotatedHandler class subclasses from Tornado's RequestHandler. Subclasses of the AnnotatedHandler are able to - declare path and query params, json body model and the response model in the function signature - validate, type cast and pass in declared params before declared methods are executed","title":"The AnnotatedHandler class"},{"location":"request_handler/#differences","text":"With Tornado, we subclass from the RequestHandler and define the path parameter in the overridden get method. We then retrieve query params and json body by using methods like get_query_argument and parsing the request body. from tornado.escape import json_decode from tornado.web import RequestHandler class TornadoRequestHandler ( RequestHandler ): async def get ( self , a_path_param ): a_query_param = int ( self . get_query_argument ( \"a_query_param\" )) a_request_body = json_decode ( self . request . body ) self . write ( { \"a_path_param\" : a_path_param , \"a_query_param\" : a_query_param , \"a_request_body\" : a_request_body , } ) For subclasses of AnnotatedHandler , the annotated function arguments are used to parse the incoming request for the required fields, and passed into the functions. from torn_open import AnnotatedHandler , RequestModel , ResponseModel class ARequestBody ( RequestModel ): a_body_param : bool class AResponseModel ( ResponseModel ): a_path_param : str a_query_param : int request_body : ARequestBody class TornOpenAnnotatedHandler ( AnnotatedHandler ): async def get ( self , a_path_param : str , a_query_param : int , a_request_body : ARequestBody ) -> AResponseModel : return AResponseModel ( a_path_param = a_path_param , a_query_param = a_query_param , a_request_body = a_request_body , )","title":"Differences"},{"location":"request_handler/#parameters","text":"The AnnotatedHandler uses a set of rules to determine where the parameter should be parsed from","title":"Parameters"},{"location":"request_handler/#path-parameters","text":"If an argument appears in the url rule for the handler, it is treated as a path parameter 1 or more path parameters can be declared in the url rule. If the url rule includes a path parameter that is not in the function signature, an error may be raised at runtime.","title":"Path parameters"},{"location":"request_handler/#query-parameters","text":"If an argument does not appear in the url rule for the handler, and its type annotation is not a subclass of torn_open.RequestModel , it is treated as a query parameter.","title":"Query parameters"},{"location":"request_handler/#json-body","text":"If an argument does not appear in the url rule for the handler, and its type annotation is a subclass of torn_open.RequestModel , then it is parsed as a JSON object. Only 1 argument in a function can be annotated as a subclass of torn_open.RequestModel .","title":"JSON body"},{"location":"type_annotations/","text":"Type annotations and models \u00b6 Annotations in the function signature serve 2 purposes 1. Type checking, validation and casting are done before being passed into the overridden methods in the AnnotatedHandler 2. On application start, every AnnotatedHandler will be parsed and inspected to generate OpenAPI specifications Supported type annotations \u00b6 The following types are currently supported, with more being planned. Primitives \u00b6 Python Type Javascript Type Values bool boolean 0, 1, \"true\", \"false\", \"TruE\", \"False\" str string \"this is a string\" int number 1, 2, -1, 99999 float number 1, 2, 1.1, -1.99999 Enum string Generics \u00b6 Python Type Javascript Type Values List[str] array \"1,2,3\" Tuple[int, str] array \"1,a string\" * Primitives that are currently supported are also supported as primitives for generics Request and response models \u00b6 RequestModel and ResponseModel are used for defining json request and response bodies. Both are subclasses from pydantic's BaseModel Currently, only single models are supported; Union of models are not supported.","title":"Type Annotations and Schema"},{"location":"type_annotations/#type-annotations-and-models","text":"Annotations in the function signature serve 2 purposes 1. Type checking, validation and casting are done before being passed into the overridden methods in the AnnotatedHandler 2. On application start, every AnnotatedHandler will be parsed and inspected to generate OpenAPI specifications","title":"Type annotations and models"},{"location":"type_annotations/#supported-type-annotations","text":"The following types are currently supported, with more being planned.","title":"Supported type annotations"},{"location":"type_annotations/#primitives","text":"Python Type Javascript Type Values bool boolean 0, 1, \"true\", \"false\", \"TruE\", \"False\" str string \"this is a string\" int number 1, 2, -1, 99999 float number 1, 2, 1.1, -1.99999 Enum string","title":"Primitives"},{"location":"type_annotations/#generics","text":"Python Type Javascript Type Values List[str] array \"1,2,3\" Tuple[int, str] array \"1,a string\" * Primitives that are currently supported are also supported as primitives for generics","title":"Generics"},{"location":"type_annotations/#request-and-response-models","text":"RequestModel and ResponseModel are used for defining json request and response bodies. Both are subclasses from pydantic's BaseModel Currently, only single models are supported; Union of models are not supported.","title":"Request and response models"}]}